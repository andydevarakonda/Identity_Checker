"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareAppZipData = void 0;
const json_1 = require("./json");
function removeDslComments(dslFileContent) {
    return dslFileContent.replace(/\/\*[\s\S]*?\*\/|\/\/.*/g, "").trim();
}
function parseDslImports(dslFileContent) {
    const importRE = /import "(.*)"/g;
    const content = removeDslComments(dslFileContent);
    let match;
    const matches = [];
    while ((match = importRE.exec(content)) !== null) {
        matches.push(match[1]);
    }
    return matches;
}
async function findSingleAppConfig(directory) {
    const glob = await Promise.resolve().then(() => __importStar(require("glob")));
    const { promises: fs } = await Promise.resolve().then(() => __importStar(require("fs")));
    let files = glob.sync(`${directory}/*.dashaapp`);
    files = files.filter(async (f) => (await fs.lstat(f)).isFile());
    if (files.length === 0)
        throw new Error(`No .dashaapp file was detected in path '${directory}'`);
    if (files.length > 1)
        throw new Error(`Multiple .dashaapp files were detected: ${files.join(", ")}`);
    const dashaappFilePath = files[0];
    return dashaappFilePath;
}
async function parseValidateAppConfig(appConfigPath) {
    var _a;
    const { promises: fs } = await Promise.resolve().then(() => __importStar(require("fs")));
    let config;
    try {
        config = JSON.parse(await fs.readFile(appConfigPath, "utf-8"));
    }
    catch (e) {
        throw new Error(`Could not parse .dashaapp config file: ${e.message}`);
    }
    if (!json_1.ApplicationConfig.validate(config)) {
        throw new Error((_a = json_1.ApplicationConfig.validate.errors) === null || _a === void 0 ? void 0 : _a.join("\n"));
    }
    return config;
}
async function collectDslFilePathsInner(dslFilePath, result) {
    const { promises: fs } = await Promise.resolve().then(() => __importStar(require("fs")));
    const path = await Promise.resolve().then(() => __importStar(require("path")));
    await fs
        .lstat(dslFilePath)
        .catch((e) => {
        throw new Error(`File ${dslFilePath} was not found`);
    })
        .then((f) => {
        if (!f.isFile() || path.parse(dslFilePath).ext !== ".dsl")
            throw new Error(`${dslFilePath} is not a dsl file`);
    });
    if (result.includes(dslFilePath))
        return;
    result.push(dslFilePath);
    const dslFileContent = await fs.readFile(dslFilePath, "utf-8");
    const importedRelPaths = parseDslImports(dslFileContent);
    for (const relPath of importedRelPaths) {
        const absPath = path.resolve(path.parse(dslFilePath).dir, relPath);
        await collectDslFilePathsInner(absPath, result);
    }
}
async function collectDslFilePaths(mainFilePath) {
    const result = [];
    await collectDslFilePathsInner(mainFilePath, result);
    return result;
}
async function getRootFolder(filePaths) {
    const path = await Promise.resolve().then(() => __importStar(require("path")));
    if (filePaths.length === 1)
        return path.dirname(filePaths[0]);
    const rootFolderSplit = filePaths.reduce((prev, cur, curInd) => {
        cur = path.normalize(cur).split(path.sep);
        if (curInd === 1)
            prev = path.normalize(prev).split(path.sep);
        const largest = prev.length > cur.length ? prev : cur;
        for (const ind in largest) {
            if (cur[ind] != prev[ind])
                return prev.slice(0, ind);
        }
        return cur;
    });
    let rootFolder = rootFolderSplit.join(path.sep);
    if (!rootFolder.includes(path.sep))
        rootFolder += path.sep;
    return rootFolder;
}
/**
 * Collects files used in application and prepares them for archiving.
 * Archived dsl files are stored in the folder '__dsl_dialogue',
 *  for this reason, the dialogue root file path is fixed in application config content.
 * The other archived file paths are relative paths for 'appFolderPath'
 * @param appFolderPath Application folder with single .dashaapp file in the root
 * @returns mapping of archive path to content.
 */
async function prepareAppZipData(appFolderPath) {
    var _a, _b;
    const path = await Promise.resolve().then(() => __importStar(require("path")));
    const { promises: fs } = await Promise.resolve().then(() => __importStar(require("fs")));
    const dashaappFilePathAbs = path.resolve(await findSingleAppConfig(appFolderPath));
    /** collect absolute paths of application files */
    const appConfig = await parseValidateAppConfig(dashaappFilePathAbs);
    const resolveConfigPath = (p) => {
        const relPath = path.join(path.parse(dashaappFilePathAbs).dir, p);
        return path.resolve(relPath);
    };
    const appFilePathsAbs = {
        mainDsl: resolveConfigPath(appConfig.dialogue.file),
        phrasemap: resolveConfigPath(appConfig.nlg.file),
        signatureFile: appConfig.nlg.signatureFile === undefined
            ? undefined
            : resolveConfigPath(appConfig.nlg.signatureFile),
        dataset: ((_a = appConfig.nlu.customIntents) === null || _a === void 0 ? void 0 : _a.file) === undefined
            ? undefined
            : resolveConfigPath((_b = appConfig.nlu.customIntents) === null || _b === void 0 ? void 0 : _b.file),
    };
    /** collect dependent dsl files recursively */
    const dslFilePathsAbs = await collectDslFilePaths(appFilePathsAbs.mainDsl);
    const dslRootFolder = await getRootFolder(dslFilePathsAbs);
    const createDslArchivePath = (p) => {
        p = path.join("__dsl_dialogue", path.relative(dslRootFolder, p));
        return p.split(path.sep).join(path.posix.sep);
    };
    const createArchivePath = (p) => {
        p = path.relative(path.resolve(appFolderPath), p);
        return p.split(path.sep).join(path.posix.sep);
    };
    /** add used files to zip */
    const archiveData = {};
    for (const p of dslFilePathsAbs)
        archiveData[createDslArchivePath(p)] = await fs.readFile(p, "utf-8");
    const restFiles = [appFilePathsAbs.phrasemap];
    if (appFilePathsAbs.signatureFile !== undefined)
        restFiles.push(appFilePathsAbs.signatureFile);
    if (appFilePathsAbs.dataset !== undefined)
        restFiles.push(appFilePathsAbs.dataset);
    for (const p of restFiles)
        archiveData[createArchivePath(p)] = await fs.readFile(p, "utf-8");
    /** substitute dsl entry point */
    appConfig.dialogue.file = createDslArchivePath(appFilePathsAbs.mainDsl);
    /** add fixed config to zip */
    archiveData[path.relative(path.resolve(appFolderPath), dashaappFilePathAbs)] =
        JSON.stringify(appConfig);
    return archiveData;
}
exports.prepareAppZipData = prepareAppZipData;
//# sourceMappingURL=zip-helpers.js.map